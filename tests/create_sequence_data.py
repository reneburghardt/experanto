import shutil
from contextlib import closing, contextmanager
from pathlib import Path

import numpy as np
import yaml

from experanto.interpolators import Interpolator

SEQUENCE_ROOT = Path("tests/sequence_data")


def _generate_sequence_data(
    sequence_root,
    n_signals=10,
    shifts_per_signal=False,
    use_mem_mapped=False,
    t_end=10.0,
    sampling_rate=10.0,
    contain_nans=False,
):
    sequence_root.mkdir(parents=True, exist_ok=True)
    (sequence_root / "meta").mkdir(parents=True, exist_ok=True)

    meta = {
        "start_time": 0,
        "end_time": t_end,
        "modality": "sequence",
        "sampling_rate": sampling_rate,
        "phase_shift_per_signal": shifts_per_signal,
        "is_mem_mapped": use_mem_mapped,
        "n_signals": n_signals,
    }

    timestamps = np.linspace(
        meta["start_time"],
        meta["end_time"],
        int((meta["end_time"] - meta["start_time"]) * meta["sampling_rate"]) + 1,
    )
    np.save(sequence_root / "timestamps.npy", timestamps)
    meta["n_timestamps"] = len(timestamps)

    data = np.random.rand(len(timestamps), n_signals)

    if contain_nans:
        nan_indices = np.random.choice(
            data.size, size=int(0.1 * data.size), replace=False
        )
        data.flat[nan_indices] = np.nan

    if not use_mem_mapped:
        np.save(sequence_root / "data.npy", data)
    else:
        filename = sequence_root / "data.mem"

        fp = np.memmap(filename, dtype=data.dtype, mode="w+", shape=data.shape)
        fp[:] = data[:]
        fp.flush()  # Ensure data is written to disk
        del fp
    meta["dtype"] = str(data.dtype)

    if shifts_per_signal:
        shifts = np.random.rand(n_signals) / meta["sampling_rate"] * 0.9
        np.save(sequence_root / "meta" / "phase_shifts.npy", shifts)

    with open(sequence_root / "meta.yml", "w") as f:
        yaml.dump(meta, f)

    return timestamps, data, shifts if shifts_per_signal else None


@contextmanager
def create_sequence_data(
    n_signals=10,
    shifts_per_signal=False,
    use_mem_mapped=False,
    t_end=10.0,
    sampling_rate=10.0,
    contain_nans=False,
):
    try:
        yield _generate_sequence_data(
            sequence_root=SEQUENCE_ROOT,
            n_signals=n_signals,
            shifts_per_signal=shifts_per_signal,
            use_mem_mapped=use_mem_mapped,
            t_end=t_end,
            sampling_rate=sampling_rate,
            contain_nans=contain_nans,
        )
    finally:
        shutil.rmtree(SEQUENCE_ROOT)


@contextmanager
def sequence_data_and_interpolator(data_kwargs=None, interp_kwargs=None):
    data_kwargs = data_kwargs or {}
    interp_kwargs = interp_kwargs or {}
    with create_sequence_data(**data_kwargs) as (timestamps, data, shifts):
        with closing(
            Interpolator.create("tests/sequence_data", **interp_kwargs)
        ) as seq_interp:
            yield timestamps, data, shifts, seq_interp
